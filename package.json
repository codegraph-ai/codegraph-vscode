{
    "name": "codegraph",
    "displayName": "CodeGraph",
    "description": "Cross-language code intelligence powered by graph analysis",
    "version": "0.5.0",
    "publisher": "aStudioPlus",
    "license": "Apache-2.0",
    "repository": {
        "type": "git",
        "url": "https://github.com/codegraph-ai/codegraph-vscode"
    },
    "engines": {
        "vscode": "^1.90.0"
    },
    "categories": [
        "Programming Languages",
        "Linters",
        "Other"
    ],
    "keywords": [
        "code intelligence",
        "cross-language",
        "code graph",
        "navigation",
        "AI"
    ],
    "icon": "images/icon.png",
    "activationEvents": [
        "onLanguage:python",
        "onLanguage:rust",
        "onLanguage:typescript",
        "onLanguage:javascript",
        "onLanguage:go",
        "onLanguage:c"
    ],
    "main": "./out/extension.js",
    "contributes": {
        "commands": [
            {
                "command": "codegraph.showDependencyGraph",
                "title": "Show Dependency Graph",
                "category": "CodeGraph"
            },
            {
                "command": "codegraph.showCallGraph",
                "title": "Show Call Graph",
                "category": "CodeGraph"
            },
            {
                "command": "codegraph.analyzeImpact",
                "title": "Analyze Impact",
                "category": "CodeGraph"
            },
            {
                "command": "codegraph.showMetrics",
                "title": "Show Parser Metrics",
                "category": "CodeGraph"
            },
            {
                "command": "codegraph.openAIChat",
                "title": "Open AI Assistant",
                "category": "CodeGraph"
            },
            {
                "command": "codegraph.reindex",
                "title": "Reindex Workspace",
                "category": "CodeGraph"
            },
            {
                "command": "codegraph.debugTools",
                "title": "Debug Language Model Tools",
                "category": "CodeGraph"
            },
            {
                "command": "codegraph.refreshMemories",
                "title": "Refresh Memories",
                "category": "CodeGraph",
                "icon": "$(refresh)"
            },
            {
                "command": "codegraph.searchMemories",
                "title": "Search Memories",
                "category": "CodeGraph",
                "icon": "$(search)"
            },
            {
                "command": "codegraph.clearMemorySearch",
                "title": "Clear Memory Search",
                "category": "CodeGraph",
                "icon": "$(clear-all)"
            },
            {
                "command": "codegraph.toggleInvalidatedMemories",
                "title": "Toggle Invalidated Memories",
                "category": "CodeGraph",
                "icon": "$(filter)"
            },
            {
                "command": "codegraph.storeMemory",
                "title": "Store Memory",
                "category": "CodeGraph",
                "icon": "$(add)"
            },
            {
                "command": "codegraph.showMemory",
                "title": "Show Memory Details",
                "category": "CodeGraph"
            },
            {
                "command": "codegraph.invalidateMemory",
                "title": "Invalidate Memory",
                "category": "CodeGraph",
                "icon": "$(trash)"
            },
            {
                "command": "codegraph.memoryStats",
                "title": "Memory Statistics",
                "category": "CodeGraph",
                "icon": "$(graph)"
            },
            {
                "command": "codegraph.mineGitHistory",
                "title": "Mine Git History for Memories",
                "category": "CodeGraph"
            }
        ],
        "configuration": {
            "title": "CodeGraph",
            "properties": {
                "codegraph.enabled": {
                    "type": "boolean",
                    "default": true,
                    "description": "Enable CodeGraph extension"
                },
                "codegraph.languages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "default": [
                        "python",
                        "rust",
                        "typescript",
                        "javascript",
                        "go",
                        "c"
                    ],
                    "description": "Languages to index"
                },
                "codegraph.indexOnStartup": {
                    "type": "boolean",
                    "default": true,
                    "description": "Index workspace on startup"
                },
                "codegraph.maxFileSizeKB": {
                    "type": "number",
                    "default": 1024,
                    "description": "Maximum file size to index (KB)"
                },
                "codegraph.excludePatterns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "default": [
                        "**/node_modules/**",
                        "**/target/**",
                        "**/__pycache__/**",
                        "**/dist/**",
                        "**/build/**",
                        "**/.git/**"
                    ],
                    "description": "Glob patterns for files to exclude"
                },
                "codegraph.includePrivate": {
                    "type": "boolean",
                    "default": true,
                    "description": "Include private/internal symbols"
                },
                "codegraph.includeTests": {
                    "type": "boolean",
                    "default": true,
                    "description": "Include test files and functions"
                },
                "codegraph.ai.maxContextTokens": {
                    "type": "number",
                    "default": 4000,
                    "description": "Maximum tokens for AI context"
                },
                "codegraph.ai.contextStrategy": {
                    "type": "string",
                    "enum": [
                        "minimal",
                        "smart",
                        "maximum"
                    ],
                    "default": "smart",
                    "description": "AI context selection strategy"
                },
                "codegraph.visualization.defaultDepth": {
                    "type": "number",
                    "default": 3,
                    "description": "Default depth for graph visualizations"
                },
                "codegraph.cache.enabled": {
                    "type": "boolean",
                    "default": true,
                    "description": "Enable query caching"
                },
                "codegraph.cache.maxSizeMB": {
                    "type": "number",
                    "default": 500,
                    "description": "Maximum cache size (MB)"
                },
                "codegraph.parallelParsing": {
                    "type": "boolean",
                    "default": true,
                    "description": "Enable parallel file parsing"
                },
                "codegraph.trace.server": {
                    "type": "string",
                    "enum": [
                        "off",
                        "messages",
                        "verbose"
                    ],
                    "default": "off",
                    "description": "Trace communication with the language server"
                },
                "codegraph.memory.enabled": {
                    "type": "boolean",
                    "default": true,
                    "description": "Enable the memory layer for storing project knowledge"
                },
                "codegraph.memory.autoInvalidate": {
                    "type": "boolean",
                    "default": true,
                    "description": "Automatically invalidate memories when linked code changes"
                },
                "codegraph.memory.showInvalidated": {
                    "type": "boolean",
                    "default": false,
                    "description": "Show invalidated memories in the tree view by default"
                },
                "codegraph.memory.gitMining.enabled": {
                    "type": "boolean",
                    "default": true,
                    "description": "Enable mining memories from git history"
                },
                "codegraph.memory.gitMining.maxCommits": {
                    "type": "number",
                    "default": 500,
                    "description": "Maximum number of commits to process when mining git history"
                },
                "codegraph.memory.gitMining.minConfidence": {
                    "type": "number",
                    "default": 0.7,
                    "minimum": 0,
                    "maximum": 1,
                    "description": "Minimum confidence score (0-1) for creating memories from commits"
                }
            }
        },
        "chatParticipants": [
            {
                "id": "codegraph",
                "fullName": "CodeGraph",
                "name": "codegraph",
                "description": "Provides code intelligence context from CodeGraph - dependency graphs, call graphs, impact analysis, and related code",
                "isSticky": false,
                "commands": [
                    {
                        "name": "dependencies",
                        "description": "Show dependency graph for the current file"
                    },
                    {
                        "name": "callgraph",
                        "description": "Show call graph for the function at cursor"
                    },
                    {
                        "name": "impact",
                        "description": "Analyze impact of changes to the current symbol"
                    },
                    {
                        "name": "tests",
                        "description": "Find tests related to the current code"
                    },
                    {
                        "name": "context",
                        "description": "Get comprehensive code context for AI analysis"
                    }
                ]
            }
        ],
        "languageModelTools": [
            {
                "name": "codegraph_get_dependency_graph",
                "displayName": "Get Dependency Graph",
                "description": "Retrieve the dependency graph for a source file showing imports and dependencies",
                "modelDescription": "Analyzes file import/dependency relationships. USE WHEN: understanding module architecture, finding circular dependencies, planning refactoring, or tracing import chains. RETURNS: Graph with nodes (files/modules) and edges (import relationships). Set direction='importedBy' to find reverse dependencies. EXAMPLE: To see what imports utils.ts, call with uri='file:///path/to/utils.ts' and direction='importedBy'. LIMITATIONS: External packages shown only with includeExternal=true.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "dependency_graph",
                "userDescription": "Analyzes file dependencies and import relationships in your codebase",
                "tags": [
                    "code-analysis",
                    "dependencies",
                    "architecture",
                    "imports",
                    "modules"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "uri": {
                            "type": "string",
                            "description": "The file URI to analyze (e.g., file:///path/to/file.ts)"
                        },
                        "depth": {
                            "type": "number",
                            "description": "How many levels of dependencies to traverse (1-10, default: 3)",
                            "default": 3
                        },
                        "includeExternal": {
                            "type": "boolean",
                            "description": "Whether to include external dependencies from node_modules/packages",
                            "default": false
                        },
                        "direction": {
                            "type": "string",
                            "enum": [
                                "imports",
                                "importedBy",
                                "both"
                            ],
                            "description": "Direction to analyze: 'imports' (what this file uses), 'importedBy' (what uses this file), or 'both'",
                            "default": "both"
                        },
                        "summary": {
                            "type": "boolean",
                            "description": "Return a condensed summary for large graphs",
                            "default": false
                        }
                    },
                    "required": [
                        "uri"
                    ]
                }
            },
            {
                "name": "codegraph_get_call_graph",
                "displayName": "Get Call Graph",
                "description": "Retrieve the call graph for a function showing callers and callees",
                "modelDescription": "Maps function call relationships showing callers and callees. USE WHEN: tracing execution flow, understanding function usage, finding dead code, or debugging. RETURNS: Graph with caller/callee nodes and call-site locations. Use direction='callers' for 'who calls this?' or direction='callees' for 'what does this call?'. EXAMPLE: To find all functions calling handleRequest, use uri+line pointing to handleRequest with direction='callers'. LIMITATIONS: Tracks static calls only; dynamic dispatch and callbacks may be incomplete.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "call_graph",
                "userDescription": "Shows function call relationships and execution flow in your code",
                "tags": [
                    "code-analysis",
                    "functions",
                    "call-graph",
                    "debugging",
                    "execution-flow"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "uri": {
                            "type": "string",
                            "description": "The file URI containing the function"
                        },
                        "line": {
                            "type": "number",
                            "description": "Line number of the function (0-indexed)"
                        },
                        "character": {
                            "type": "number",
                            "description": "Character position in the line (0-indexed)",
                            "default": 0
                        },
                        "depth": {
                            "type": "number",
                            "description": "How many levels deep to traverse the call graph",
                            "default": 3
                        },
                        "direction": {
                            "type": "string",
                            "enum": [
                                "callers",
                                "callees",
                                "both"
                            ],
                            "description": "Direction: 'callers' (who calls this), 'callees' (what this calls), or 'both'",
                            "default": "both"
                        },
                        "summary": {
                            "type": "boolean",
                            "description": "Return a condensed summary for large call graphs",
                            "default": false
                        }
                    },
                    "required": [
                        "uri",
                        "line"
                    ]
                }
            },
            {
                "name": "codegraph_analyze_impact",
                "displayName": "Analyze Change Impact",
                "description": "Analyze the impact of modifying, deleting, or renaming a symbol",
                "modelDescription": "Predicts blast radius of code changes before making them. USE WHEN: planning refactoring, renaming symbols, deleting code, or assessing risk. RETURNS: Direct impacts (immediate usages) and indirect impacts (transitive dependencies) with file locations and risk scores. EXAMPLE: Before renaming validateUser, call with changeType='rename' to see all affected files. ALWAYS USE THIS before modifying public APIs or shared utilities. LIMITATIONS: May miss dynamic references or reflection-based usage.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "impact_analysis",
                "userDescription": "Analyzes the impact of code changes before you make them",
                "tags": [
                    "code-analysis",
                    "refactoring",
                    "impact",
                    "risk-assessment",
                    "planning"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "uri": {
                            "type": "string",
                            "description": "The file URI containing the symbol"
                        },
                        "line": {
                            "type": "number",
                            "description": "Line number of the symbol (0-indexed)"
                        },
                        "character": {
                            "type": "number",
                            "description": "Character position (0-indexed)",
                            "default": 0
                        },
                        "changeType": {
                            "type": "string",
                            "enum": [
                                "modify",
                                "delete",
                                "rename"
                            ],
                            "description": "Type of change to analyze",
                            "default": "modify"
                        },
                        "summary": {
                            "type": "boolean",
                            "description": "Return a condensed summary when many impacts are found",
                            "default": false
                        }
                    },
                    "required": [
                        "uri",
                        "line"
                    ]
                }
            },
            {
                "name": "codegraph_get_ai_context",
                "displayName": "Get AI Context",
                "description": "Get comprehensive code context optimized for AI analysis",
                "modelDescription": "Gathers comprehensive code context optimized for AI understanding. USE WHEN: explaining code, planning modifications, debugging issues, or writing tests. RETURNS: Primary code + intelligently selected related code (dependencies, callers, types) within token budget. Set intent='debug' for error-tracing context or intent='test' for test-writing context. EXAMPLE: For explaining a complex function, call with intent='explain' to get the function plus its dependencies and type definitions. THIS IS YOUR PRIMARY TOOL for understanding unfamiliar code.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "ai_context",
                "userDescription": "Provides rich code context for AI analysis and understanding",
                "tags": [
                    "code-analysis",
                    "ai",
                    "context",
                    "understanding",
                    "primary-tool"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "uri": {
                            "type": "string",
                            "description": "The file URI to get context for"
                        },
                        "line": {
                            "type": "number",
                            "description": "Line number (0-indexed)"
                        },
                        "character": {
                            "type": "number",
                            "description": "Character position (0-indexed)",
                            "default": 0
                        },
                        "intent": {
                            "type": "string",
                            "enum": [
                                "explain",
                                "modify",
                                "debug",
                                "test"
                            ],
                            "description": "What you plan to do with the context. Affects which related code is selected.",
                            "default": "explain"
                        },
                        "maxTokens": {
                            "type": "number",
                            "description": "Maximum tokens of context to return",
                            "default": 4000
                        }
                    },
                    "required": [
                        "uri",
                        "line"
                    ]
                }
            },
            {
                "name": "codegraph_find_related_tests",
                "displayName": "Find Related Tests",
                "description": "Find test files and test functions related to a code location",
                "modelDescription": "Discovers test files and functions that exercise specific code. USE WHEN: modifying code to know which tests to run/update, debugging to find test cases that reproduce issues, or assessing test coverage. RETURNS: List of test functions with file locations and relevance scores. EXAMPLE: Before refactoring UserService, call this to find all tests that exercise UserService methods. Works with Jest, Pytest, Rust tests, Go tests, and more.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "related_tests",
                "userDescription": "Finds tests related to your code for testing and debugging",
                "tags": [
                    "testing",
                    "code-analysis",
                    "quality",
                    "debugging",
                    "coverage"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "uri": {
                            "type": "string",
                            "description": "The file URI to find tests for"
                        },
                        "line": {
                            "type": "number",
                            "description": "Line number (0-indexed)",
                            "default": 0
                        },
                        "limit": {
                            "type": "number",
                            "description": "Maximum number of related tests to return",
                            "default": 10
                        }
                    },
                    "required": [
                        "uri"
                    ]
                }
            },
            {
                "name": "codegraph_get_symbol_info",
                "displayName": "Get Symbol Information",
                "description": "Get detailed information about a symbol (function, class, variable, etc.)",
                "modelDescription": "Gets quick metadata about any symbol (function, class, variable, type). USE WHEN: you need to quickly understand what a symbol is, check its signature, or see usage count. RETURNS: Name, kind, signature, documentation, location, visibility, and reference count. FASTER than codegraph_get_ai_context when you only need basic info. Set includeReferences=true to get all usage locations (slower). Falls back to nearest symbol if line is blank.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "symbol_info",
                "userDescription": "Shows detailed information about code symbols and their usage",
                "tags": [
                    "code-analysis",
                    "symbols",
                    "documentation",
                    "quick-lookup",
                    "metadata"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "uri": {
                            "type": "string",
                            "description": "The file URI containing the symbol"
                        },
                        "line": {
                            "type": "number",
                            "description": "Line number of the symbol (0-indexed)"
                        },
                        "character": {
                            "type": "number",
                            "description": "Character position (0-indexed)",
                            "default": 0
                        },
                        "includeReferences": {
                            "type": "boolean",
                            "description": "Whether to include all references to the symbol. Can be slow on large workspaces.",
                            "default": false
                        }
                    },
                    "required": [
                        "uri",
                        "line"
                    ]
                }
            },
            {
                "name": "codegraph_analyze_complexity",
                "displayName": "Analyze Complexity",
                "description": "Analyze cyclomatic and cognitive complexity of code",
                "modelDescription": "Measures code complexity metrics for refactoring decisions. USE WHEN: identifying functions that need simplification, reviewing code quality, or prioritizing technical debt. RETURNS: Cyclomatic complexity, cognitive complexity, nesting depth, and lines of code. Omit line parameter to analyze entire file and rank functions by complexity. EXAMPLE: To find the most complex functions in auth.ts, call with just uri. Scores >10 typically indicate refactoring candidates.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "complexity",
                "userDescription": "Analyzes code complexity metrics to identify areas needing refactoring",
                "tags": [
                    "code-analysis",
                    "complexity",
                    "quality",
                    "refactoring",
                    "metrics"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "uri": {
                            "type": "string",
                            "description": "The file URI to analyze"
                        },
                        "line": {
                            "type": "number",
                            "description": "Optional line number to analyze a specific function (0-indexed)"
                        },
                        "threshold": {
                            "type": "number",
                            "description": "Complexity threshold for flagging (default: 10)",
                            "default": 10
                        },
                        "summary": {
                            "type": "boolean",
                            "description": "Return a condensed summary",
                            "default": false
                        }
                    },
                    "required": [
                        "uri"
                    ]
                }
            },
            {
                "name": "codegraph_find_unused_code",
                "displayName": "Find Unused Code",
                "description": "Detect unused functions, variables, and imports in the codebase",
                "modelDescription": "Detects dead code that can be safely removed. USE WHEN: cleaning up codebase, reducing bundle size, or finding abandoned features. RETURNS: Unused functions, classes, and variables with confidence scores (0-1). Use scope='workspace' for comprehensive cleanup. EXAMPLE: To find all unused exports across the project, call with scope='workspace' and confidence=0.8. LIMITATIONS: May flag entry points, event handlers, or dynamically-called code; always verify before deleting.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "unused_code",
                "userDescription": "Finds unused code that can be safely removed from your codebase",
                "tags": [
                    "code-analysis",
                    "cleanup",
                    "quality",
                    "dead-code",
                    "maintenance"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "uri": {
                            "type": "string",
                            "description": "The file URI to analyze (optional for workspace scope)"
                        },
                        "scope": {
                            "type": "string",
                            "enum": [
                                "file",
                                "module",
                                "workspace"
                            ],
                            "description": "Scope of analysis: 'file', 'module', or 'workspace'",
                            "default": "file"
                        },
                        "includeTests": {
                            "type": "boolean",
                            "description": "Whether to include test files in analysis",
                            "default": false
                        },
                        "confidence": {
                            "type": "number",
                            "description": "Minimum confidence threshold (0-1) for reporting unused code",
                            "default": 0.7
                        },
                        "summary": {
                            "type": "boolean",
                            "description": "Return a condensed summary",
                            "default": false
                        }
                    }
                }
            },
            {
                "name": "codegraph_analyze_coupling",
                "displayName": "Analyze Coupling",
                "description": "Analyze module coupling and cohesion metrics",
                "modelDescription": "Measures module coupling for architectural analysis. USE WHEN: evaluating module boundaries, planning decoupling refactoring, or assessing architectural health. RETURNS: Afferent coupling (Ca - who depends on this), efferent coupling (Ce - what this depends on), and instability metric (Ce/(Ca+Ce)). High instability (>0.8) suggests fragile module; low instability (<0.2) suggests stable core. EXAMPLE: Analyze a utils module to see if it's properly abstracted or has too many dependents.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "coupling",
                "userDescription": "Analyzes module coupling and cohesion for better architecture",
                "tags": [
                    "code-analysis",
                    "architecture",
                    "quality",
                    "coupling",
                    "design"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "uri": {
                            "type": "string",
                            "description": "The file URI to analyze"
                        },
                        "includeExternal": {
                            "type": "boolean",
                            "description": "Whether to include external dependencies in analysis",
                            "default": false
                        },
                        "depth": {
                            "type": "number",
                            "description": "Depth of dependency analysis",
                            "default": 2
                        },
                        "summary": {
                            "type": "boolean",
                            "description": "Return a condensed summary",
                            "default": false
                        }
                    },
                    "required": [
                        "uri"
                    ]
                }
            },
            {
                "name": "codegraph_symbol_search",
                "displayName": "Search Symbols",
                "description": "Search for symbols (functions, classes, variables) in the codebase using natural language or pattern matching",
                "modelDescription": "Searches codebase for symbols by name or pattern. USE WHEN: finding function/class implementations, exploring unfamiliar code, or locating specific functionality. RETURNS: Ranked results with name, kind, location, and relevance scores. Supports fuzzy matching. EXAMPLE: Search 'validate user' to find validateUser, userValidation, etc. Use symbolType='function' to filter. THIS IS YOUR STARTING POINT when you don't know where code is located.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "symbol_search",
                "userDescription": "Search for functions, classes, and variables by name or description",
                "tags": [
                    "search",
                    "symbols",
                    "code-navigation",
                    "discovery",
                    "primary-tool"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "query": {
                            "type": "string",
                            "description": "Search query - can be a symbol name, partial name, or descriptive text"
                        },
                        "symbolType": {
                            "type": "string",
                            "enum": [
                                "function",
                                "class",
                                "method",
                                "variable",
                                "interface",
                                "type",
                                "module",
                                "any"
                            ],
                            "description": "Filter results by symbol type",
                            "default": "any"
                        },
                        "limit": {
                            "type": "number",
                            "description": "Maximum number of results to return",
                            "default": 20
                        },
                        "includePrivate": {
                            "type": "boolean",
                            "description": "Include private/internal symbols in results",
                            "default": true
                        }
                    },
                    "required": [
                        "query"
                    ]
                }
            },
            {
                "name": "codegraph_find_by_imports",
                "displayName": "Find By Imports",
                "description": "Find code that imports or uses specific modules, packages, or libraries",
                "modelDescription": "Finds all files importing a specific module or package. USE WHEN: planning library migrations, finding all React component usages, or discovering internal module consumers. RETURNS: Files that import the module with import statements and locations. EXAMPLE: To find all lodash usage before migration, search moduleName='lodash'. Use matchMode='prefix' to find 'lodash/map', 'lodash/filter', etc.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "find_imports",
                "userDescription": "Find all code that imports or uses a specific module or package",
                "tags": [
                    "search",
                    "imports",
                    "dependencies",
                    "migration",
                    "library-usage"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "moduleName": {
                            "type": "string",
                            "description": "Name of the module/package to search for (e.g., 'lodash', 'react', './utils')"
                        },
                        "matchMode": {
                            "type": "string",
                            "enum": [
                                "exact",
                                "prefix",
                                "contains",
                                "fuzzy"
                            ],
                            "description": "How to match the module name",
                            "default": "contains"
                        },
                        "limit": {
                            "type": "number",
                            "description": "Maximum number of results",
                            "default": 50
                        }
                    },
                    "required": [
                        "moduleName"
                    ]
                }
            },
            {
                "name": "codegraph_find_entry_points",
                "displayName": "Find Entry Points",
                "description": "Find application entry points like main functions, HTTP handlers, CLI commands, and event handlers",
                "modelDescription": "Discovers application entry points and execution starting points. USE WHEN: understanding app architecture, tracing request flow, or finding where to start debugging. RETURNS: main() functions, HTTP handlers (Express/FastAPI/Actix), CLI commands, event handlers, and tests. EXAMPLE: Use entryType='http_handler' to map all API endpoints. Use framework='express' to filter to Express routes only. START HERE when exploring unfamiliar backend applications.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "entry_points",
                "userDescription": "Discover main functions, HTTP handlers, CLI commands, and other entry points",
                "tags": [
                    "architecture",
                    "entry-points",
                    "code-navigation",
                    "api",
                    "routing"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "entryType": {
                            "type": "string",
                            "enum": [
                                "main",
                                "http_handler",
                                "cli_command",
                                "event_handler",
                                "test",
                                "all"
                            ],
                            "description": "Type of entry point to find",
                            "default": "all"
                        },
                        "framework": {
                            "type": "string",
                            "description": "Filter by framework (e.g., 'express', 'fastapi', 'actix')"
                        },
                        "limit": {
                            "type": "number",
                            "description": "Maximum number of results",
                            "default": 50
                        }
                    }
                }
            },
            {
                "name": "codegraph_traverse_graph",
                "displayName": "Traverse Code Graph",
                "description": "Traverse the code graph from a starting point following specific relationship types",
                "modelDescription": "Advanced graph traversal for complex code exploration. USE WHEN: specialized analysis requiring custom traversal (not covered by get_callers/get_callees/get_dependency_graph). Specify edgeTypes=['calls','imports'] to follow specific relationships. RETURNS: Nodes at each depth with relationship paths. Falls back to nearest symbol if line is blank. PREFER simpler tools (get_callers, get_dependency_graph) for common cases; use this for custom multi-edge-type traversals.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "traverse",
                "userDescription": "Explore code relationships by traversing the code graph",
                "tags": [
                    "graph",
                    "traversal",
                    "code-analysis",
                    "advanced",
                    "relationships"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "uri": {
                            "type": "string",
                            "description": "File URI (e.g., file:///path/to/file.ts). Use with line to identify the starting symbol."
                        },
                        "line": {
                            "type": "number",
                            "description": "0-based line number of the symbol. Use with uri to identify the starting symbol."
                        },
                        "startNodeId": {
                            "type": "string",
                            "description": "Internal node ID from symbol_search. Alternative to uri+line."
                        },
                        "direction": {
                            "type": "string",
                            "enum": [
                                "outgoing",
                                "incoming",
                                "both"
                            ],
                            "description": "Direction to traverse edges",
                            "default": "outgoing"
                        },
                        "edgeTypes": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            },
                            "description": "Types of edges to follow (e.g., ['calls', 'imports'])"
                        },
                        "nodeTypes": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            },
                            "description": "Filter results to specific node types"
                        },
                        "maxDepth": {
                            "type": "number",
                            "description": "Maximum traversal depth",
                            "default": 3
                        },
                        "limit": {
                            "type": "number",
                            "description": "Maximum number of nodes to return",
                            "default": 100
                        }
                    }
                }
            },
            {
                "name": "codegraph_get_callers",
                "displayName": "Get Function Callers",
                "description": "Get all functions that call a specific function",
                "modelDescription": "Finds all functions that call a target function (reverse call graph). USE WHEN: understanding function usage, finding all invocation sites, or assessing change impact. RETURNS: List of calling functions with file locations and call sites. Use depth>1 to find transitive callers (callers of callers). Falls back to nearest symbol if line is blank. SIMPLER than traverse_graph for this common use case.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "callers",
                "userDescription": "Find all functions that call a specific function",
                "tags": [
                    "call-graph",
                    "functions",
                    "references",
                    "usage",
                    "impact"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "uri": {
                            "type": "string",
                            "description": "File URI (e.g., file:///path/to/file.ts). Use with line to identify the function."
                        },
                        "line": {
                            "type": "number",
                            "description": "0-based line number of the function. Use with uri to identify the function."
                        },
                        "nodeId": {
                            "type": "string",
                            "description": "Internal node ID from symbol_search. Alternative to uri+line."
                        },
                        "depth": {
                            "type": "number",
                            "description": "Depth of caller chain to traverse (default: 1)",
                            "default": 1
                        }
                    }
                }
            },
            {
                "name": "codegraph_get_callees",
                "displayName": "Get Function Callees",
                "description": "Get all functions that a specific function calls",
                "modelDescription": "Finds all functions called by a target function (forward call graph). USE WHEN: understanding function dependencies, tracing execution flow, or analyzing what code a function touches. RETURNS: List of called functions with file locations. Use depth>1 to find transitive callees (functions called by callees). Falls back to nearest symbol if line is blank. SIMPLER than traverse_graph for this common use case.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "callees",
                "userDescription": "Find all functions that a specific function calls",
                "tags": [
                    "call-graph",
                    "functions",
                    "dependencies",
                    "execution-flow",
                    "tracing"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "uri": {
                            "type": "string",
                            "description": "File URI (e.g., file:///path/to/file.ts). Use with line to identify the function."
                        },
                        "line": {
                            "type": "number",
                            "description": "0-based line number of the function. Use with uri to identify the function."
                        },
                        "nodeId": {
                            "type": "string",
                            "description": "Internal node ID from symbol_search. Alternative to uri+line."
                        },
                        "depth": {
                            "type": "number",
                            "description": "Depth of callee chain to traverse (default: 1)",
                            "default": 1
                        }
                    }
                }
            },
            {
                "name": "codegraph_get_detailed_symbol",
                "displayName": "Get Detailed Symbol Info",
                "description": "Get comprehensive information about a specific symbol including source code, documentation, and relationships",
                "modelDescription": "Gets comprehensive symbol details including source code and relationships. USE WHEN: you need full context about a symbol - source code, callers, callees, complexity, and metadata together. RETURNS: Source code, signature, documentation, callers list, callees list, complexity score, and visibility. MORE COMPLETE than get_symbol_info but heavier. Falls back to nearest symbol if line is blank. Use includeCallers/includeCallees=false for faster results.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "symbol_details",
                "userDescription": "Get complete details about a function, class, or variable",
                "tags": [
                    "symbols",
                    "documentation",
                    "code-analysis",
                    "comprehensive",
                    "source-code"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "uri": {
                            "type": "string",
                            "description": "File URI (e.g., file:///path/to/file.ts). Use with line to identify the symbol."
                        },
                        "line": {
                            "type": "number",
                            "description": "0-based line number of the symbol. Use with uri to identify the symbol."
                        },
                        "nodeId": {
                            "type": "string",
                            "description": "Internal node ID from symbol_search. Alternative to uri+line."
                        },
                        "includeSource": {
                            "type": "boolean",
                            "description": "Include full source code of the symbol",
                            "default": true
                        },
                        "includeCallers": {
                            "type": "boolean",
                            "description": "Include list of callers",
                            "default": true
                        },
                        "includeCallees": {
                            "type": "boolean",
                            "description": "Include list of callees",
                            "default": true
                        }
                    }
                }
            },
            {
                "name": "codegraph_find_by_signature",
                "displayName": "Find By Signature",
                "description": "Find functions by their signature pattern - parameter count, return type, or modifiers",
                "modelDescription": "Finds functions matching signature patterns. USE WHEN: searching by structural characteristics rather than names - parameter count, return types, or modifiers. RETURNS: Functions matching the pattern with signatures and locations. EXAMPLE: Find all async handlers with modifiers=['async'] and namePattern='*Handler'. Find functions taking 3+ params with minParams=3. Combine returnType='Promise' with modifiers=['async'] for async functions.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "find_signature",
                "userDescription": "Find functions by parameter count, return type, or modifiers",
                "tags": [
                    "search",
                    "functions",
                    "signatures",
                    "patterns",
                    "structural-search"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "namePattern": {
                            "type": "string",
                            "description": "Pattern to match function names (supports wildcards like 'get*', '*Handler')"
                        },
                        "paramCount": {
                            "type": "number",
                            "description": "Exact number of parameters"
                        },
                        "minParams": {
                            "type": "number",
                            "description": "Minimum number of parameters"
                        },
                        "maxParams": {
                            "type": "number",
                            "description": "Maximum number of parameters"
                        },
                        "returnType": {
                            "type": "string",
                            "description": "Return type to match (e.g., 'Promise', 'Result<T>', 'void')"
                        },
                        "modifiers": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            },
                            "description": "Required modifiers (e.g., ['async'], ['static', 'public'])"
                        },
                        "limit": {
                            "type": "number",
                            "description": "Maximum number of results",
                            "default": 50
                        }
                    }
                }
            },
            {
                "name": "codegraph_memory_store",
                "displayName": "Store Memory",
                "description": "Store a memory for future retrieval - debug contexts, architectural decisions, known issues, or conventions",
                "modelDescription": "Persists knowledge for future sessions. USE WHEN: discovering important context worth remembering - debugging insights, architectural decisions, known issues, coding conventions, or project-specific knowledge. RETURNS: Memory ID for retrieval. KIND OPTIONS: 'debug_context' (problem+solution), 'architectural_decision' (decision+rationale), 'known_issue' (description+severity), 'convention' (pattern to follow), 'project_context' (general knowledge). EXAMPLE: After solving a tricky bug, store with kind='debug_context' so future sessions benefit. LINK TO CODE with codeLinks for automatic relevance scoring.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "memory_store",
                "userDescription": "Store knowledge for future AI sessions - debug insights, decisions, issues, and conventions",
                "tags": [
                    "memory",
                    "persistence",
                    "knowledge",
                    "context",
                    "learning"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "kind": {
                            "type": "string",
                            "enum": [
                                "debug_context",
                                "architectural_decision",
                                "known_issue",
                                "convention",
                                "project_context"
                            ],
                            "description": "Type of memory being stored"
                        },
                        "title": {
                            "type": "string",
                            "description": "Short descriptive title for the memory"
                        },
                        "content": {
                            "type": "string",
                            "description": "Main content of the memory"
                        },
                        "tags": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            },
                            "description": "Tags for categorization and search"
                        },
                        "codeLinks": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "nodeId": {
                                        "type": "string"
                                    },
                                    "nodeType": {
                                        "type": "string"
                                    }
                                }
                            },
                            "description": "Links to related code graph nodes for relevance scoring"
                        },
                        "confidence": {
                            "type": "number",
                            "description": "Confidence level 0.0-1.0 (default: 1.0)",
                            "default": 1
                        },
                        "problem": {
                            "type": "string",
                            "description": "For debug_context: describe the problem encountered"
                        },
                        "solution": {
                            "type": "string",
                            "description": "For debug_context: describe the solution found"
                        },
                        "decision": {
                            "type": "string",
                            "description": "For architectural_decision: the decision made"
                        },
                        "rationale": {
                            "type": "string",
                            "description": "For architectural_decision: reasoning behind the decision"
                        },
                        "description": {
                            "type": "string",
                            "description": "For known_issue/convention/project_context: detailed description"
                        },
                        "severity": {
                            "type": "string",
                            "enum": [
                                "critical",
                                "high",
                                "medium",
                                "low"
                            ],
                            "description": "For known_issue: severity level"
                        }
                    },
                    "required": [
                        "kind",
                        "title",
                        "content"
                    ]
                }
            },
            {
                "name": "codegraph_memory_search",
                "displayName": "Search Memories",
                "description": "Search stored memories using hybrid semantic and keyword search",
                "modelDescription": "Searches memories with hybrid BM25 + semantic + graph proximity. USE WHEN: recalling past knowledge - previous debugging sessions, architectural decisions, known issues. RETURNS: Ranked memories with relevance scores. Pass codeContext (node IDs) to boost memories linked to current code. EXAMPLE: When debugging auth, search 'authentication issues' with codeContext pointing to auth functions. ALWAYS SEARCH before starting complex tasks to leverage past knowledge.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "memory_search",
                "userDescription": "Search for stored memories, debug contexts, and project knowledge",
                "tags": [
                    "memory",
                    "search",
                    "knowledge",
                    "recall",
                    "context"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "query": {
                            "type": "string",
                            "description": "Search query - supports natural language"
                        },
                        "limit": {
                            "type": "number",
                            "description": "Maximum results to return",
                            "default": 10
                        },
                        "tags": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            },
                            "description": "Filter by tags"
                        },
                        "kinds": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            },
                            "description": "Filter by memory kinds"
                        },
                        "currentOnly": {
                            "type": "boolean",
                            "description": "Only return non-invalidated memories",
                            "default": true
                        },
                        "codeContext": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            },
                            "description": "Code node IDs for proximity boosting"
                        }
                    },
                    "required": [
                        "query"
                    ]
                }
            },
            {
                "name": "codegraph_memory_get",
                "displayName": "Get Memory",
                "description": "Retrieve a specific memory by its ID",
                "modelDescription": "Retrieves full memory details by ID. USE WHEN: you have a memory ID from search results and need complete content. RETURNS: Full memory with all fields, code links, and metadata. Use after memory_search to get complete details of relevant memories.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "memory_get",
                "userDescription": "Get full details of a specific memory by ID",
                "tags": [
                    "memory",
                    "retrieval",
                    "details"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "id": {
                            "type": "string",
                            "description": "Memory ID to retrieve"
                        }
                    },
                    "required": [
                        "id"
                    ]
                }
            },
            {
                "name": "codegraph_memory_context",
                "displayName": "Get Memory Context",
                "description": "Get memories relevant to a specific code location",
                "modelDescription": "Finds memories relevant to current code location. USE WHEN: starting work on a file/function to see past context. RETURNS: Memories linked to or semantically related to the code location, with relevance explanations. EXAMPLE: When opening auth.ts, call with uri to see past debugging sessions, known issues, and decisions about that code. THIS SHOULD BE YOUR FIRST CALL when starting work on unfamiliar code.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "memory_context",
                "userDescription": "Find memories relevant to your current code location",
                "tags": [
                    "memory",
                    "context",
                    "relevance",
                    "code-aware"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "uri": {
                            "type": "string",
                            "description": "File URI to find relevant memories for"
                        },
                        "line": {
                            "type": "number",
                            "description": "Optional line number for more specific context"
                        },
                        "character": {
                            "type": "number",
                            "description": "Optional character position"
                        },
                        "limit": {
                            "type": "number",
                            "description": "Maximum memories to return",
                            "default": 5
                        },
                        "kinds": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            },
                            "description": "Filter by memory kinds"
                        }
                    },
                    "required": [
                        "uri"
                    ]
                }
            },
            {
                "name": "codegraph_memory_invalidate",
                "displayName": "Invalidate Memory",
                "description": "Mark a memory as no longer current/valid",
                "modelDescription": "Marks memory as outdated without deleting. USE WHEN: knowledge is superseded, bugs are fixed, decisions are reversed. RETURNS: Success status. Invalidated memories are hidden by default but retained for history. EXAMPLE: After fixing a bug documented in memory, invalidate that debug_context. This maintains history while preventing outdated info from surfacing.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "memory_invalidate",
                "userDescription": "Mark a memory as outdated or no longer applicable",
                "tags": [
                    "memory",
                    "management",
                    "invalidation"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "id": {
                            "type": "string",
                            "description": "Memory ID to invalidate"
                        }
                    },
                    "required": [
                        "id"
                    ]
                }
            },
            {
                "name": "codegraph_memory_list",
                "displayName": "List Memories",
                "description": "List memories with optional filtering by kind and tags",
                "modelDescription": "Lists memories with filtering and pagination. USE WHEN: browsing available memories or auditing stored knowledge. RETURNS: Paginated list with summary info. Use to discover what project knowledge exists before starting work.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "memory_list",
                "userDescription": "Browse stored memories with filtering options",
                "tags": [
                    "memory",
                    "list",
                    "browse",
                    "management"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "kinds": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            },
                            "description": "Filter by memory kinds"
                        },
                        "tags": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            },
                            "description": "Filter by tags"
                        },
                        "currentOnly": {
                            "type": "boolean",
                            "description": "Only show non-invalidated memories",
                            "default": true
                        },
                        "limit": {
                            "type": "number",
                            "description": "Maximum results per page",
                            "default": 20
                        },
                        "offset": {
                            "type": "number",
                            "description": "Offset for pagination",
                            "default": 0
                        }
                    }
                }
            },
            {
                "name": "codegraph_memory_stats",
                "displayName": "Memory Statistics",
                "description": "Get statistics about stored memories",
                "modelDescription": "Returns memory store statistics. USE WHEN: understanding what knowledge is stored, checking memory health, or debugging memory issues. RETURNS: Counts by kind, tag distributions, current vs invalidated ratios.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "memory_stats",
                "userDescription": "View statistics about your stored memories",
                "tags": [
                    "memory",
                    "statistics",
                    "management"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {}
                }
            },
            {
                "name": "codegraph_mine_git_history",
                "displayName": "Mine Git History",
                "description": "Extract memories from git commit history - bug fixes, architectural decisions, and breaking changes",
                "modelDescription": "Mines git history to automatically create memories from commits. USE WHEN: setting up a new project, onboarding to unfamiliar code, or wanting to capture institutional knowledge. RETURNS: Count of commits processed and memories created. EXTRACTS: Bug fixes (fix:, closes #), architectural decisions (arch:, adr:), breaking changes (BREAKING:), and reverts. EXAMPLE: Call at project start to capture debugging history and architectural context. Memories are tagged 'git-mined' and 'auto' for filtering. Works best with conventional commit messages.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "mine_git",
                "userDescription": "Extract knowledge from git commit history into memories",
                "tags": [
                    "git",
                    "mining",
                    "memory",
                    "history",
                    "automation"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "maxCommits": {
                            "type": "number",
                            "description": "Maximum commits to process (default: 500)",
                            "default": 500
                        },
                        "minConfidence": {
                            "type": "number",
                            "description": "Minimum confidence score to create memory (0.0-1.0, default: 0.7)",
                            "default": 0.7
                        },
                        "mineBugFixes": {
                            "type": "boolean",
                            "description": "Extract debug contexts from bug fix commits",
                            "default": true
                        },
                        "mineArchDecisions": {
                            "type": "boolean",
                            "description": "Extract architectural decisions",
                            "default": true
                        },
                        "mineBreakingChanges": {
                            "type": "boolean",
                            "description": "Extract known issues from breaking changes",
                            "default": true
                        },
                        "mineReverts": {
                            "type": "boolean",
                            "description": "Extract known issues from revert commits",
                            "default": true
                        }
                    }
                }
            },
            {
                "name": "codegraph_mine_git_history_for_file",
                "displayName": "Mine Git History for File",
                "description": "Extract memories from git history for a specific file",
                "modelDescription": "Mines git history for a specific file to create memories. USE WHEN: investigating a problematic file, understanding why code exists, or tracing bug history. RETURNS: File-specific memories from commits that touched the file. EXAMPLE: When debugging auth.ts, mine its history to find past fixes and known issues. More focused than full repository mining.",
                "canBeReferencedInPrompt": true,
                "toolReferenceName": "mine_git_file",
                "userDescription": "Extract knowledge from git history for a specific file",
                "tags": [
                    "git",
                    "mining",
                    "memory",
                    "history",
                    "file-specific"
                ],
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "uri": {
                            "type": "string",
                            "description": "File URI to mine history for (e.g., file:///path/to/file.ts)"
                        },
                        "maxCommits": {
                            "type": "number",
                            "description": "Maximum commits to process (default: 100)",
                            "default": 100
                        }
                    },
                    "required": [
                        "uri"
                    ]
                }
            }
        ],
        "menus": {
            "editor/context": [
                {
                    "command": "codegraph.showCallGraph",
                    "group": "codegraph",
                    "when": "editorTextFocus"
                },
                {
                    "command": "codegraph.analyzeImpact",
                    "group": "codegraph",
                    "when": "editorTextFocus"
                }
            ],
            "view/title": [
                {
                    "command": "codegraph.refreshMemories",
                    "when": "view == codegraphMemories",
                    "group": "navigation@1"
                },
                {
                    "command": "codegraph.searchMemories",
                    "when": "view == codegraphMemories",
                    "group": "navigation@2"
                },
                {
                    "command": "codegraph.storeMemory",
                    "when": "view == codegraphMemories",
                    "group": "navigation@3"
                },
                {
                    "command": "codegraph.toggleInvalidatedMemories",
                    "when": "view == codegraphMemories",
                    "group": "navigation@4"
                },
                {
                    "command": "codegraph.memoryStats",
                    "when": "view == codegraphMemories",
                    "group": "navigation@5"
                }
            ],
            "view/item/context": [
                {
                    "command": "codegraph.invalidateMemory",
                    "when": "view == codegraphMemories && viewItem == memory-current",
                    "group": "inline"
                }
            ]
        },
        "views": {
            "explorer": [
                {
                    "id": "codegraphSymbols",
                    "name": "CodeGraph Symbols",
                    "when": "codegraph.enabled"
                },
                {
                    "id": "codegraphMemories",
                    "name": "CodeGraph Memories",
                    "when": "codegraph.enabled"
                }
            ]
        },
        "viewsWelcome": [
            {
                "view": "codegraphMemories",
                "contents": "No memories stored yet.\n[Store Memory](command:codegraph.storeMemory)\n[Mine Git History](command:codegraph.mineGitHistory)"
            }
        ]
    },
    "scripts": {
        "vscode:prepublish": "npm run esbuild-base -- --production && ./scripts/prepare-binaries.sh",
        "compile": "tsc -p ./",
        "watch": "tsc -watch -p ./",
        "esbuild-base": "node esbuild.js",
        "esbuild": "npm run esbuild-base -- --sourcemap",
        "esbuild-watch": "npm run esbuild-base -- --sourcemap --watch",
        "build-server": "cargo build --release -p codegraph-lsp",
        "build-webview": "cd webview && npm run build",
        "package": "vsce package",
        "lint": "eslint src --ext ts",
        "test": "vitest run",
        "test:watch": "vitest",
        "test:e2e": "npm run compile && node ./out/test/runTest.js"
    },
    "devDependencies": {
        "@types/node": "^20.10.0",
        "@types/vscode": "^1.85.0",
        "@typescript-eslint/eslint-plugin": "^6.13.0",
        "@typescript-eslint/parser": "^6.13.0",
        "@vitest/coverage-v8": "^1.0.0",
        "@vscode/vsce": "^2.22.0",
        "@vsforge/config": "file:../vsforge/packages/@vsforge/config",
        "@vsforge/shim": "file:../vsforge/packages/@vsforge/shim",
        "@vsforge/test": "file:../vsforge/packages/@vsforge/test",
        "esbuild": "^0.27.1",
        "eslint": "^8.55.0",
        "typescript": "^5.3.0",
        "vitest": "^1.0.0"
    },
    "dependencies": {
        "vscode-languageclient": "^9.0.1"
    }
}
